# Табло теннисного матча

Табло теннисного матча - это веб-приложение, предоставляющее пользователю методы для создания, проведения и хранения теннисных матчей. Основой приложения является MVCS-структура.
В качестве базы данных используется in-memory БД H2, в качестве ORM-фреймворка - Hibernate, уровень представления выполнен JSP-страницами с использованием JSTL и CSS. Для реализации тестов использован JUnit5. Выполнена
валидация доступных пользователю запросов и обработка возможных исключений с кратким и полным представлением для пользователя.
[ссылка на деплой](http://109.120.139.74:8080/). 

## Функционал

Данное веб-приложение реализует функционал:

1. **Создание теннисного матча с существующими в БД или созданными пользователем новыми игроками**
2. **Проведение и сохранение подсчета очков в текущем матче согласно правилам большого тенниса**
3. **Определение победителя и отображение счета завершенного матча (в том числе по геймам в каждом сете)**
4. **Сохранение завершенного матча в базу данных**
5. **Выдача пользователю списка всех/отфильтрованных по имени матчей на страницах по 5 строк в каждой с пагинацией**

## Правила тенниса

Функционал данного приложения реализован на основе базовых правил большого тенниса, с которыми можно ознакомиться
по [ссылке](https://www.gotennis.ru/read/world_of_tennis/pravila.html). Основные особенности:
1. **Матч играется до двух сетов (best of 3)**
2. **При счёте 6/6 в сете, играется тай-брейк до 7 очков**
   
## Особенности реализации

### Представление
В данном проекте в качестве представления использованы JSP-страницы.
В рамках готового фронтэнда к проекту реализованы 4 базовые страницы, а также 2 дополнительные:
1. **index.jsp**
Стартовая страница с ссылками на страницы создания нового матча и архива матчей
2. **new-match.jsp**
Страница создания нового матча с 2 полями для ввода имен игроков. При нарушении валидации над этими полями появляется сообщение 
с нарушенными условиями. При нажатии кнопки "Start" происходит валидация введенных имен игроков, в случае успешного прохождения производится
запрос в базу данных. Если игрок или оба игрока с введенными именами существуют, новые игроки в базе данных не создаются.
3. **match-score.jsp**
Основная страница приложения, на которой происходит подсчет очков матча. Нажатие кнопки "Score" приводит к POST-запросу с id игрока, заработавшего очко.
При соблюдении условий, при которых матч считается завершенным, происходит редирект на страницу завершенного матча
4. **matches.jsp**
Архив матчей с возможностью фильтрации и поиска по имени игроков. Фильтрация выполнена так, что предоставляет пользователю не только те строки, имена в которых идеально
совпадают с именами игроков в БД, но и те, в которых введенное значение является частью имен. Последние проведенные матчи отображаются первыми
5. **error.jsp**
Страница, отображающая данные о случившемся исключении. На ней указан код ошибки, ее имя, сообщение, а также стэк-трейс.   
6. **finished-match.jsp**
Страница, отображающая статистику завершенного матча (с историей геймов). Также отображает победителя и предоставляет возможность перехода на остальные страницы приложения.

### Filter

В данном проете использован функционал @WebFilter для обработки исключений. Обработкой занимается ExceptionHandler, однако валидация имен на странице создания нового матча не является исключением и не обрабатывается этим фильтром

### Пагинация

Пагинация выполнена с дополнениями к ТЗ - Добавлены ссылки на первую и последнеюю страницы архива матчей, появляющихся лишь тогда, когда на них нельзя попасть в 1 клик из соседних.
Данные для пагинации берутся отдельным запросом, но в рамках одной с основным запросом транзакции, после чего возвращаются на уровень сервлетов и представления в классе-обертке Page с полями 
List<MatchDto> matchDtos и int pagesNumber.

### ApplicationInitializer

В проекте используется контекст, инициализируемый в классе ApplicationInitializer. Благодаря этому все сервисы, используемые в приложении, являются синглтонами и инициализируются единожды при подъеме приложения.

### Repository

Для вынесения общей логики, повышения читаемости кода и избавления от его дублирования, на уровне репозитория реализован класс QueryBuilder, позволяющий реализовать единообразную, понятную и лишенную повторов кода логику.

### Сервисы

Межсервисное взаимодействие полностью вынесено на слой сервлетов, валидация выполняется в отдельном сервисе ValidatorService.

### Заполнение таблиц

В связи с тем, что Hibernate самостоятельно создает таблицы на основе аннотаций классов-entity, для их стартового заполнения используется скрипт, который исполняется методами класса ScriptReader

### Тесты

Для реализации тестов ипользован JUnit5. Тестами покрыты основные пограничные ситуации при подсчете очков, такие как тай-брекйк, больше-меньше, инкрементирование очков геймов/сетов при достижении необходимого количества очков.

## Заключение

Приятного пользования, буду благодарен любой обратной связи по проекту.
